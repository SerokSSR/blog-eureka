<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>算法 on Eureka Demo</title>
    <link>https://www.atsnow.tk/categories/%E7%AE%97%E6%B3%95/</link>
    <description>Recent content in 算法 on Eureka Demo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>&amp;copy; 2021 &lt;a href=&#34;https://www.wangchucheng.com/&#34;&gt;C. Wang&lt;/a&gt; and &lt;a href=&#34;https://www.ruiqima.com/&#34;&gt;R. Ma&lt;/a&gt;</copyright>
    <lastBuildDate>Tue, 04 Feb 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://www.atsnow.tk/categories/%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>尺取法</title>
      <link>https://www.atsnow.tk/ruler-method/</link>
      <pubDate>Tue, 04 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.atsnow.tk/ruler-method/</guid>
      <description>尺取法 与单调队列相关 要求在满足条件的情况下，长度越长，答案越好（下简称具有单调性）. 利用双指针 $l,r$ 及队列思想，对于同一个 $l$ 让 $r$ 尽可能延伸至最远，得到一个</description>
    </item>
    
    <item>
      <title>About CODESTYLE</title>
      <link>https://www.atsnow.tk/about-codestyle/</link>
      <pubDate>Tue, 21 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.atsnow.tk/about-codestyle/</guid>
      <description>commit 命名规范 feat: 一个新功能 fix: 一个 bug 修复 docs: 仅仅修改了文档，比如 README, CHANGELOG, CONTRIBUTE 等 style: 不影响代码逻辑的修改，比如空格、格式缩进、删除分号等 refactor: 代码重构 perf: 提升性能的改动 test: 增加</description>
    </item>
    
    <item>
      <title>C&#43;&#43; STL：SET &amp; MULTISET</title>
      <link>https://www.atsnow.tk/stl-set/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.atsnow.tk/stl-set/</guid>
      <description>C++ STL：SET &amp;amp; MULTISET 定义 方式 效果 set &amp;lt;数据类型名&amp;gt; 集合名; 先定义一个容器，容器内无任何元素 set &amp;lt;数据类型名&amp;gt; 集合名(另一个集合名)</description>
    </item>
    
    <item>
      <title>CF387D</title>
      <link>https://www.atsnow.tk/cf387d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.atsnow.tk/cf387d/</guid>
      <description>CF387D 题意分析 操作最少的次数，构成有趣图，注意无重边，有向边。 操作分为加边和删边。 有趣图定义 有一个中心，满足此点有自环，且与其他结点有双向边。 除中心点外的</description>
    </item>
    
    <item>
      <title>D2T1：贪心、二分、并查集</title>
      <link>https://www.atsnow.tk/noip-d2t1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.atsnow.tk/noip-d2t1/</guid>
      <description>常见的贪心技巧 货币使用问题： 尽可能少用，那么我们就先拿面值最大的，依次往下走，最后拿光了即可。 区间调度问题： 工作时间不能重叠，在可选工作中，每次都选取</description>
    </item>
    
    <item>
      <title>匹配：模板</title>
      <link>https://www.atsnow.tk/match-template/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.atsnow.tk/match-template/</guid>
      <description>匹配：模板 UOJ78 二分图最大匹配（DFS - KM） #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;iostream&amp;gt; using namespace std; const int N = 550; int match[N], g[N][N], vis[N], link[N]; int n, m, e, tag, ans = 0; bool dfs(int u) { for(int v=1; v&amp;lt;=m; ++v) { if(!g[u][v] or vis[v] == tag) continue; vis[v] = tag; if(!match[v] or dfs(match[v])) { match[v] = u; return true;</description>
    </item>
    
    <item>
      <title>单调队列</title>
      <link>https://www.atsnow.tk/monotonous-queue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.atsnow.tk/monotonous-queue/</guid>
      <description>单调队列 具有单调性的队列。当一新值准备入队时，须先从后向前，将对后来答案没有了影响的点弹出，再从前向后，将所有超出了统计范围的点弹出。对于大多数问题，</description>
    </item>
    
    <item>
      <title>图论</title>
      <link>https://www.atsnow.tk/graph-theory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.atsnow.tk/graph-theory/</guid>
      <description>图论 图论算法一般都是揉在一起的，很难单独把算法拆开讲，所以直接上题目吧。分类是大致分的，其实有很多是交叉的。 二叉树 二叉树的遍历有三种，分别为前序遍历，</description>
    </item>
    
    <item>
      <title>图论：LCA</title>
      <link>https://www.atsnow.tk/graph-lca/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.atsnow.tk/graph-lca/</guid>
      <description>LCA: Lowest common ancestor最近公共祖先 倍增求LCA 预处理向上跳2^k步的结果f[k][x] $O(n \log n)$ 求的时候先把两个点跳到一个深度，这里有一个特判，如果重合直</description>
    </item>
    
    <item>
      <title>图论：Tarjan</title>
      <link>https://www.atsnow.tk/graph-tarjan/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.atsnow.tk/graph-tarjan/</guid>
      <description>前置概念 时间戳：搜索时第几个搜索到这个点。如搜索顺序是1-&amp;gt;2-&amp;gt;3-&amp;gt;6，则6的时间戳为4 对于无向图 连通分量：对于图G来的一个子图</description>
    </item>
    
    <item>
      <title>搜索与状压 DP</title>
      <link>https://www.atsnow.tk/dp-graph/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.atsnow.tk/dp-graph/</guid>
      <description>DFS 众所周知，搜索和DP是不分家的，几乎所有的DP都可以转化为搜索。当想不出正解时，DFS也是骗分的好手段。 主要的搜索手段有： DFS/BFS爆搜 双向BF</description>
    </item>
    
    <item>
      <title>数论：不定方程整数解</title>
      <link>https://www.atsnow.tk/num-exgcd/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.atsnow.tk/num-exgcd/</guid>
      <description>扩展欧几里得 求不定 $ax+by=c$ 的所有整数解。 判断该方程是否有解 裴蜀定理：设 $\gcd(a, b) = d$，则对任意整数x, y，有d|(ax + by) 成立； 特别地，一定存在x, y 满足ax +</description>
    </item>
    
    <item>
      <title>浅谈 Splay（一）</title>
      <link>https://www.atsnow.tk/about-splay/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.atsnow.tk/about-splay/</guid>
      <description>一、旋转（Zig - Zag） 1. 右旋（Right Rotation） 观察每个节点的变化，其中每个节点都有指向其父节点的指针没有画出。 ①②③处节点连接有变化。</description>
    </item>
    
    <item>
      <title>简单动态规划：LIS、LCS、背包</title>
      <link>https://www.atsnow.tk/dp-linear/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.atsnow.tk/dp-linear/</guid>
      <description>P1020 导弹拦截 #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; const int N = 100010; int n = 0; int a[N], b[N], s[N], ls[N]; void add(int x, int v) { for(; x&amp;lt;=n; x+=x&amp;amp;(-x)) s[x] = max(s[x], v); } int query(int x) { int ans = 0; for(; x&amp;gt;0; x-=x&amp;amp;(-x)) ans = max(ans, s[x]); return ans; } int main() { //freopen(&amp;quot;p1020_1.in&amp;quot;, &amp;quot;r&amp;quot;, stdin); for(; scanf(&amp;quot;%d&amp;quot;, a+n+1) != EOF; ++n, b[n]</description>
    </item>
    
    <item>
      <title>简单数论</title>
      <link>https://www.atsnow.tk/num-theory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.atsnow.tk/num-theory/</guid>
      <description>简单数论 一点都不简单 欧几里得算法 又称辗转相除法 迭代求两数 gcd 的做法 由 $(a, b) = (a, ka + b)$ 的性质：$\gcd(a, b) = \gcd(b, a\bmod b)$ 容易证明这么做的复杂度是 $O(\log n)$ 注意：$</description>
    </item>
    
    <item>
      <title>网络流：Dijkstra 求费用流</title>
      <link>https://www.atsnow.tk/network-flow-dijkstra/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.atsnow.tk/network-flow-dijkstra/</guid>
      <description>网络流：Dijkstra 求费用流 注：下文中的边权 $w$ 均表示费用 $f$。 Dijkstra 不能求有负权边的最短路，所以我们可以对网络 $G$ 中的每一个点设置一个势函数 $h(u)</description>
    </item>
    
    <item>
      <title>网络流：最大流</title>
      <link>https://www.atsnow.tk/maximum-flow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.atsnow.tk/maximum-flow/</guid>
      <description>网络流：最大流 EK 增广路方法是很多网络流算法的基础。其思路是每次找出一条从源到汇的能够增加流的路径，调整流值和残留网络 ，直到没有增广路为止。 EK 算法就是不</description>
    </item>
    
    <item>
      <title>网络流：最小割</title>
      <link>https://www.atsnow.tk/minimum-cut/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.atsnow.tk/minimum-cut/</guid>
      <description>网络流：最小割 将图 $G$ 分为 $A$ 和 $B$ 两个点集，$A$ 和 $B$ 之间的边的集合称为无向图的割集。带权图的割 (Cut) 就是割集中的边权之和。 S - T 最小割 特别地，对于一个网络，</description>
    </item>
    
    <item>
      <title>网络流：模板</title>
      <link>https://www.atsnow.tk/network-flow-template/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.atsnow.tk/network-flow-template/</guid>
      <description>网络流：模板 P3376 网络最大流（Dinic） #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;queue&amp;gt; using namespace std; const int N = 11000, M = 110000; const int INF = 0x7fffffff; struct node { int u, v, w, next; } e[M &amp;lt;&amp;lt; 1]; int cur[N], h[N], tot; int dfn[N], ans, n, m, s, t; void add(int u, int v, int w) { e[tot]</description>
    </item>
    
    <item>
      <title>网络流：消圈算法</title>
      <link>https://www.atsnow.tk/network-flow-deloop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.atsnow.tk/network-flow-deloop/</guid>
      <description>网络流：消圈算法 注：下文中的权均表示费用。 消圈定理 在某个流 $f$ 中，如果其残余网络中没有负圈（剩余流量为 $0$ 的边视为不存在），那它一定是当前流量下的最小费用</description>
    </item>
    
    <item>
      <title>还在用 STL 排序？</title>
      <link>https://www.atsnow.tk/still-using-stl-sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.atsnow.tk/still-using-stl-sort/</guid>
      <description>还在用 STL 排序？ 使用 C 库函数 很多人都不知道的是，其实 C 语言也是自带排序函数的，就是位于 &amp;lt;stdlib.h&amp;gt; 库中的 qsort 函数声明： void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void*)) 其中 base - 指向要排序的</description>
    </item>
    
    <item>
      <title>高级动态规划：区间、树形</title>
      <link>https://www.atsnow.tk/dp-series/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.atsnow.tk/dp-series/</guid>
      <description>区间 DP P1880 [NOI1995]石子合并 #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;iostream&amp;gt; using namespace std; const int N = 220; int ans, dp[N][N], n, a[N], s[N]; int main() { scanf(&amp;quot;%d&amp;quot;, &amp;amp;n); for(int i=1; i&amp;lt;=n; ++i) { scanf(&amp;quot;%d&amp;quot;, a+i); s[i] = s[i-1] + a[i]; } for(int i=1; i&amp;lt;=n; ++i) { s[i+n] = s[i+n-1] + a[i]; } memset(dp, 0x3f, sizeof dp); for(int i=1; i&amp;lt;=2*n; ++i) dp[i][i]</description>
    </item>
    
  </channel>
</rss>
