<!DOCTYPE html>
<html lang='zh' ><meta charset="utf-8">
<meta name="viewport" content="width=device-width">


<title>尺取法 | Eureka Demo</title>
<link rel="stylesheet" href="https://www.atsnow.tk/css/eureka.min.css">
<script defer src="https://www.atsnow.tk/js/eureka.min.js"></script>

<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preload"
  href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&family=Noto+Serif+SC:wght@400;600;700&display=swap"
  as="style" onload="this.onload=null;this.rel='stylesheet'">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/styles/solarized-light.min.css"
   media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/highlight.min.js"
   crossorigin></script>
<script defer src="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/js/all.min.js"
   integrity="sha256-uNYoXefWRqv&#43;PsIF/OflNmwtKM4lStn9yrz2gVl6ymo="  crossorigin></script>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"
   integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3&#43;Aro6EYUG4&#43;cU&#43;KJWu/X"  media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" 
  integrity="sha384-g7c&#43;Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI&#43;sEnkvrMWph2EDg4"  crossorigin></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"
   integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC&#43;Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa"  crossorigin></script>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
        { left: "\\(", right: "\\)", display: false },
        { left: "\\[", right: "\\]", display: true }
      ],
    });
  });
</script>


<link rel="icon" type="image/png" sizes="32x32" href="https://www.atsnow.tk/images/icon_hu64421c6c7700f606f0ad45d807017b09_5843_32x32_fill_box_center_2.png">
<link rel="apple-touch-icon" sizes="180x180" href="https://www.atsnow.tk/images/icon_hu64421c6c7700f606f0ad45d807017b09_5843_180x180_fill_box_center_2.png">

<meta name="description"
  content="利用双指针及队列。">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
      "@type": "ListItem",
      "position": 1 ,
      "name":"Posts",
      "item":"https://www.atsnow.tk/posts/"},{
      "@type": "ListItem",
      "position": 2 ,
      "name":"尺取法",
      "item":"https://www.atsnow.tk/ruler-method/"}]
}
</script>



<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://www.atsnow.tk/ruler-method/"
    },
    "headline": "尺取法 | Eureka Demo","datePublished": "2020-02-04T00:00:00+00:00",
    "dateModified": "2020-02-04T00:00:00+00:00",
    "wordCount":  3107 ,
    "publisher": {
        "@type": "Person",
        "name": "C. Wang",
        "logo": {
            "@type": "ImageObject",
            "url": "https://www.atsnow.tk/images/icon.png"
        }
        },
    "description": "利用双指针及队列。"
}
</script><meta property="og:title" content="尺取法 | Eureka Demo" />
<meta property="og:type" content="article" />


<meta property="og:image" content="https://www.atsnow.tk/images/icon.png">


<meta property="og:url" content="https://www.atsnow.tk/ruler-method/" />



<meta property="og:description" content="利用双指针及队列。" />



<meta property="og:locale" content="zh" />




<meta property="og:site_name" content="Eureka Demo" />






<meta property="article:published_time" content="2020-02-04T00:00:00&#43;00:00" />


<meta property="article:modified_time" content="2020-02-04T00:00:00&#43;00:00" />



<meta property="article:section" content="posts" />


<meta property="article:tag" content="尺取法" />

<meta property="article:tag" content="双指针" />

<meta property="article:tag" content="单调队列" />

<meta property="article:tag" content="算法" />





<meta property="og:see_also" content="https://www.atsnow.tk/monotonous-queue/" />

<meta property="og:see_also" content="https://www.atsnow.tk/about-codestyle/" />

<meta property="og:see_also" content="https://www.atsnow.tk/cf387d/" />

<meta property="og:see_also" content="https://www.atsnow.tk/about-splay/" />

<meta property="og:see_also" content="https://www.atsnow.tk/minimum-cut/" />

<meta property="og:see_also" content="https://www.atsnow.tk/stl-set/" />



<body class="flex flex-col min-h-screen">
  <header class="fixed flex items-center w-full min-h-16 pl-scrollbar z-50 bg-secondary-bg shadow-sm">
    <div class="w-full max-w-screen-xl mx-auto"><script>
    let storageColorScheme = localStorage.getItem("lightDarkMode")
    if (((storageColorScheme == 'Auto' || storageColorScheme == null) && window.matchMedia("(prefers-color-scheme: dark)").matches) || storageColorScheme == "Dark") {
        document.getElementsByTagName('html')[0].classList.add('dark')
    }
</script>
<nav class="flex items-center justify-between flex-wrap px-4 py-4 md:py-0">
    <a href="/" class="mr-6 text-primary-text text-xl font-bold">Eureka Demo</a>
    <button id="navbar-btn" class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
        <i class="fas fa-bars"></i>
    </button>

    <div id="target"
        class="hidden block md:flex md:flex-grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20">
        <div class="md:flex md:h-16 text-sm md:flex-grow pb-4 md:pb-0 border-b md:border-b-0">
        </div>

        <div class="flex">
            <div class="relative pt-4 md:pt-0">
                <div class="cursor-pointer hover:text-eureka" id="lightDarkMode">
                    <i class="fas fa-adjust"></i>
                </div>
                <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id="is-open">
                </div>
                <div class="absolute flex flex-col left-0 md:left-auto right-auto md:right-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40"
                    id='lightDarkOptions'>
                    <span class="px-4 py-1 hover:text-eureka">Light</span>
                    <span class="px-4 py-1 hover:text-eureka">Dark</span>
                    <span class="px-4 py-1 hover:text-eureka">Auto</span>
                </div>
            </div>
        </div>
    </div>

    <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id="is-open-mobile">
    </div>

</nav>
<script>
    let element = document.getElementById('lightDarkMode')
    if (storageColorScheme == null || storageColorScheme == 'Auto') {
        document.addEventListener('DOMContentLoaded', () => {
            switchMode('Auto')
        })
    } else if (storageColorScheme == "Light") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'sun')
        element.firstElementChild.classList.add('fa-sun')
    } else if (storageColorScheme == "Dark") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'moon')
        element.firstElementChild.classList.add('fa-moon')
    }
    
    document.addEventListener('DOMContentLoaded', () => {
        getcolorscheme();
        switchBurger();
    });
</script></div>
  </header>
  <main class="flex-grow pt-16">
    <div class="pl-scrollbar">
      <div class="w-full max-w-screen-xl lg:px-4 xl:px-8 mx-auto">


<div class="grid grid-cols-2 lg:grid-cols-8 gap-4 lg:pt-12">
    <div
        class="col-span-2  lg:col-span-6 bg-secondary-bg rounded px-6 py-8">
        <h1 class="font-bold text-3xl text-primary-text">尺取法</h1>
        <div class="flex flex-wrap flex-row items-center mt-2 text-tertiary-text">
    <div class="mr-6 my-2">
        <i class="fas fa-calendar mr-1"></i>
        <span>2020-02-04</span>
    </div>
    <div class="mr-6 my-2">
        <i class="fas fa-clock mr-1"></i>
        <span>7分钟阅读时长</span>
    </div>
    
    
    <div class="mr-6 my-2">
        <i class="fas fa-folder mr-1"></i>
        
        <a href="https://www.atsnow.tk/categories/%E7%AE%97%E6%B3%95/" class="hover:text-eureka">算法</a>
        
    </div>
    

    
</div>
        
        
        

        <div class="content">
            <h1 id="尺取法">尺取法</h1>
<p><strong>与单调队列相关</strong></p>
<p>要求在满足条件的情况下，长度越长，答案越好（下简称具有单调性）.</p>
<p>利用双指针 $l,r$ 及队列思想，对于同一个 $l$ 让 $r$ 尽可能延伸至最远，得到一个答案区间，$r$ 已到达最远后将与 $l$ 有关的信息弹出，对于多个答案区间找出最优解．</p>
<h2 id="hdu5178-pairs">HDU5178 Pairs</h2>
<h3 id="题面">题面</h3>
<p>有 $n$ 个值 $x_1, x_2, \dots,x_n$，求使得 $|x_b-x_a|\leqslant k,a&lt;b$ 的数对 $(a,b)$ 的个数．</p>
<h3 id="解">解</h3>
<p>分析可知 $a&lt;b$ 这一条件只是确保无重复，次序其实对于最终答案没有影响．</p>
<p>考虑先对 $x$ 排序（因原题目有绝对值，无影响），for​ $l$ 尺取出最远的 $r$， 则 $(l,r]$  间的每个数均与 $l$ 构成合法数对．</p>
<h3 id="代码">代码</h3>
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;algorithm&gt;

const int N = 110000;
typedef long long LL;

int T, n;
LL k, x[N];

int main() {
     
    freopen(&quot;hdu5178.in&quot;, &quot;r&quot;, stdin);
     
    scanf(&quot;%d&quot;, &amp;T);
     
    while(T--) {
          
        scanf(&quot;%d%lld&quot;, &amp;n, &amp;k);
          
        for(int i=1; i&lt;=n; ++i) 
            scanf(&quot;%lld&quot;, x+i);
          
        std::sort(x+1, x+n+1);
          
        LL ans = 0;
        for(int l=1, r=2; l&lt;=n; ++l) {
            for(; r &lt;= n and x[r] - x[l] &lt;= k; ++r);
            ans += r - l - 1;
        }
         
        printf(&quot;%lld\n&quot;, ans);
    }
     
    return 0;
}
</code></pre>
<h2 id="hdu6119-小小粉丝度度熊">HDU6119 小小粉丝度度熊</h2>
<p><strong>类似 CF1041D Glider</strong></p>
<h3 id="题面-1">题面</h3>
<p>给出 $n$ 个已签到的天数区间，$m$ 张补签卡，求可获得的最大连续签到时长。</p>
<h3 id="解-1">解</h3>
<p>尺取模板。</p>
<p>天数区间可重叠，须进行合并。</p>
<p>需要注意的是，当已确定最长合法区间 $[l,r]$ 后（即下一个区间与 $r$ 的距离大于剩余的补签卡数量，连不上），应把剩余补签卡全部应用到 $r$ 之后的天数上得到更优解。</p>
<h3 id="代码-1">代码</h3>
<p>边界条件较多。</p>
<p>$R$ 为已加入队列的最后一个区间，判断的是区间 $R+1$ 的合法性。</p>
<p>特判第一个区间，开始时 $sum$ 直接加上第一个已签到区间的长，使用 $0$ 张补签卡。</p>
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;algorithm&gt;
using namespace std;

const int N = 110000;

struct node {
    int l, r;
} a[N], b[N];

bool flag[N];
bool cmp(node a, node b) { return a.l &lt; b.l; }
int n, m;
int max(int a, int b) { return a &gt; b ? a : b; }

int main() {
     
    freopen(&quot;hdu6119.in&quot;, &quot;r&quot;, stdin);
     
    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) != EOF) {
          
        for(int i=1; i&lt;=n; ++i) 
            scanf(&quot;%d%d&quot;, &amp;b[i].l, &amp;b[i].r),
            flag[i] = false;
                
        sort(b+1, b+n+1, cmp);
          
        for(int i=2; i&lt;=n; ++i) {
            if(b[i-1].r &gt;= b[i].l) {
                b[i].l = b[i-1].l;
                b[i].r = max(b[i].r, b[i-1].r);
                flag[i-1] = true;
            }
        }
          
        int tot = 0;
        for(int i=1; i&lt;=n; ++i) {
            if(flag[i]) continue;
            a[++tot].l = b[i].l;
            a[tot].r = b[i].r;
        }
         
        int sum = a[1].r - a[1].l + 1, f = 0, ans = 0;
        for(int L = 1, R = 1; L &lt;= tot; ++L) {
            for(; R + 1 &lt;= tot and f + a[R+1].l - a[R].r - 1 &lt;= m; ++R)
                sum += a[R+1].r - a[R].r,
                f += a[R+1].l - a[R].r - 1;
            ans = max(ans, sum + m - f);
            sum -= a[L+1].l - a[L].l;
            f -= a[L+1].l - a[L].r - 1;
        }
         
        printf(&quot;%d\n&quot;, ans);
    }
    
    return 0;
}
</code></pre>
<h2 id="hdu1937-finding-seats">HDU1937 Finding Seats</h2>
<h3 id="题面-2">题面</h3>
<p>电影院有 $R$ 行 $C$ 列，用 <code>'.'</code> 表示空座，<code>'X'</code> 表示不可选。</p>
<p>要求选择至少 $K$ 个空座位 $(x_i, y_i)$，使得
$$
(\max x_i -\min x_i)\cdot(\max y_i -\min y_i),1\leqslant i \leqslant K
$$
最小。</p>
<h3 id="解-2">解</h3>
<p>二维尺取。</p>
<p>枚举题目所求长方形的上下界，尺取求出左右最短距离。用二维前缀和简化空位查找。</p>
<h3 id="代码-2">代码</h3>
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
using namespace std;

const int N = 330;

int row, c, k;
char str[N];
int s[N][N];

int query(int x1, int y1, int x2, int y2) {
    return s[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1-1][y1-1];
}

int main() {
     
    freopen(&quot;hdu1937.in&quot;, &quot;r&quot;, stdin);
     
    while(true) {
         
        scanf(&quot;%d%d%d&quot;, &amp;row, &amp;c, &amp;k);
        if(row == 0 and c == 0 and k == 0)
            break;
          
        for(int i=1; i&lt;=row; ++i) {
            scanf(&quot;%s&quot;, str+1);
            int sum = 0;
            for(int j=1; j&lt;=c; ++j) {
                sum += (str[j] == '.' ? 1 : 0);
                s[i][j] = s[i-1][j] + sum;
            }
        } 
        
        int ans = 0x7fffffff;
        for(int up = 1; up &lt;= row; ++up) {
            for(int down = up; down &lt;= row; ++down) {
                for(int l=1, r=1; l&lt;=c; ++l) {
                    for(; r&lt;=c; ++r) {
                        if(query(up, l, down, r) &gt;= k) {
                            ans = min(ans, (down - up + 1) * (r - l + 1));
                            break; 
                        }
                    }
                }
            }
        }
          
        printf(&quot;%d\n&quot;, ans);
    }
     
    return 0;
}
</code></pre>
<h2 id="hdu5358-first-one">HDU5358 First One</h2>
<h3 id="题面-3">题面</h3>
<p>有一数列 $a_1, a_2, \dots, a_n$，求
$$
\sum_{i=1}^{n} \sum_{j=i}^{n} (i + j)(\lfloor \log_2 \sum_{k=i}^{j} a_k \rfloor + 1)
$$
的值。特别地，$\log_20=0$。</p>
<h3 id="解-3">解</h3>
<p>观察上式，对于 $\lfloor\log\rfloor$ 来说，它的一个值可对应很多个真数，考虑分块。</p>
<p>枚举 $\lfloor \log_2 \sum_{k=i}^{j} a_k \rfloor$ 的每一个值（1~34）。</p>
<p>令
$$
v =\lfloor \log_2 \sum_{k=i}^{j} a_k \rfloor
$$</p>
<p>$$
sum = \sum_{k=i}^{j}a_k
$$</p>
<p>则
$$
sum \in [2^{v-1},2^v)
$$
用尺取求出部分和在此范围的区段 $[i,j]$，求出结果加入计数器。</p>
<h3 id="代码-3">代码</h3>
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
using namespace std;

const int N = 110000;
typedef long long LL;

LL cl[40], a[N], s[N];
int T, n;

int main() {
     
    freopen(&quot;hdu5358.in&quot;, &quot;r&quot;, stdin);
     
    cl[0] = -1, cl[1] = 1;
    for(int i=2; i&lt;=34; ++i) cl[i] = ((cl[i-1] + 1) &lt;&lt; 1LL) - 1;
     
    scanf(&quot;%d&quot;, &amp;T);
    while(T--) {
        scanf(&quot;%d&quot;, &amp;n);
        for(int i=1; i&lt;=n; ++i) scanf(&quot;%lld&quot;, a+i);
        for(int i=1; i&lt;=n; ++i) s[i] = s[i-1] + a[i];
         
        LL ans = 0;
        for(LL k=1; k&lt;=34; ++k) {
            LL l = 0, r = 0;
            for(LL i=1; i&lt;=n; ++i) {
                for(l = max(l, i); l &lt;= n and s[l] - s[i-1] &lt;= cl[k-1]; ++l);
                for(r = max(l, r); r &lt;= n and s[r] - s[i-1] &lt;= cl[k]; ++r);
                ans += k * (i * (r-l) + (l+r-1) * (r-l) / 2);
            }
        }
        printf(&quot;%lld\n&quot;, ans);
    }
     
    return 0;
}
</code></pre>
<h2 id="hdu6103-kirinriki">HDU6103 Kirinriki</h2>
<h3 id="题面-4">题面</h3>
<p>有两字符串 $A,B$（从 $1$ 编号），长度均为 $n$，定义
$$
dis(A,B) = \sum_{i=1}^n|A_i-B_{n-i}|
$$
字符之差定义为其 ASCII 码的差。</p>
<p>对于一字符串 $S$，找出它的两个不重叠连续子串，他们的 $dis$ 不大于 $m$，求最长合法子串长度。</p>
<h3 id="解-4">解</h3>
<p>寻找单调性，易得
$$
\forall S' \subseteq S,T'\subseteq T:dis(S',T')\leqslant dis(S,T)
$$
因此子串越长越好。</p>
<p>又$\because$ $\forall$ 两个合法子串，其必关于母串的某一位置（或某两位置之间）对称，考虑枚举这一中心点，分上面的两种情况。</p>
<p>注意到对于每个子串，其长度越大越好，同时又有约束上界，可对称尺取。</p>
<h3 id="代码-4">代码</h3>
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int abs(int x) {
    return x &gt; 0 ? x : -x; 
}
int max(int a, int b) {
    return a &gt; b ? a : b;
}
int T, n, m;
char s[22000];

int main() {
     
    freopen(&quot;hdu6103.in&quot;, &quot;r&quot;, stdin);
     
    scanf(&quot;%d&quot;, &amp;T);
     
    while(T--) {
        scanf(&quot;%d&quot;, &amp;m);
        scanf(&quot;%s&quot;, s+1);
        int n = strlen(s+1), ans = 0;
          
        for(int i=1; i&lt;=n; ++i) {
            int f = 0;
            for(int l1 = i-1, r1 = i-1, l2 = i+1, r2 = i+1; l1 &gt; 0 and l2 &lt;= n; --l1, ++l2) {
                for(; r1 &gt; 0 and r2 &lt;= n and f + abs(s[r1] - s[r2]) &lt;= m; --r1, ++r2) f += abs(s[r1] - s[r2]);
                ans = max(ans, r2 - l2);
                f -= abs(s[l1] - s[l2]);
             }
        }
          
        for(int i=1; i&lt;=n; ++i) {
            int f = 0;
            for(int l1 = i, r1 = i, l2 = i+1, r2 = i+1; l1 &gt; 0 and l2 &lt;= n; --l1, ++l2) {
                for(; r1 &gt; 0 and r2 &lt;= n and f + abs(s[r1] - s[r2]) &lt;= m; --r1, ++r2) f += abs(s[r1] - s[r2]);
                ans = max(ans, r2 - l2);
                f -= abs(s[l1] - s[l2]);
            }
        }
          
        printf(&quot;%d\n&quot;, ans);
    } 
     
    return 0;
}
</code></pre>
<h2 id="poj2739-sum-of-consecutive-prime-numbers">POJ2739 Sum of Consecutive Prime Numbers</h2>
<p>尺取水题。</p>
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;cmath&gt;
using namespace std;

bool prime(int x) {
    if(x &lt; 2) return false;
    int m = int(sqrt(x));
    
    for(int i=2; i&lt;=m; ++i) 
        if(x % i == 0) return false;
    return true;
}

int x, p[11000];
int main() {
    
    int tot = 0;
    for(int i=1; i&lt;=10000; ++i) {
        if(prime(i)) p[++tot] = i;
    }
    
    while(true) {
        scanf(&quot;%d&quot;, &amp;x);
        if(x == 0) break;
        int f = 0, ans = 0;
        for(int l=1, r=1; l&lt;=tot; ++l) {
            for(; r &lt;= tot and f + p[r] &lt;= x; ++r) f += p[r];
            if(f == x) ++ans;
            f -= p[l];
        }
        printf(&quot;%d\n&quot;, ans);
    }
    
    return 0;
}
</code></pre>
<h2 id="cf1198a-mp3">CF1198A MP3</h2>
<h3 id="题面-5">题面</h3>
<p>给出 $n,I$。</p>
<p>$n$ - 数列 $a_1,a_2,&hellip;,a_n$</p>
<p>选定一个区间 $[l,r]$，并进行操作，使
$$
v_i =
\begin{cases}
l&amp;v_i&lt;l\<br>
v_i&amp;l\leqslant v_i \leqslant r\<br>
r&amp;v_i&gt;r
\end{cases}
$$
要求经过处理后，数列中不同的数的个数 $\leqslant 2^{\lfloor 8I/n\rfloor}$，且使数列中被更改的位置的总数最小，求这个最小值。</p>
<h3 id="解-5">解</h3>
<p>原题面较长，需耐心看题。</p>
<p>可先将原数列排序并离散化，记下每种数的出现次数，用前缀和优化求和。因顺序已预先排好，直接尺取 $[l,r]$，使区间内的值最大化，用总数相减得出答案。</p>
<h3 id="代码-5">代码</h3>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 440000;
 
int a[N], b[N], cnt[N], s[N], n, I, t;
 
int power(int x) {
    int ans = 1, base = 2;
    for(; x; x &gt;&gt;= 1) {
        if(x &amp; 1) ans *= base;
        if(ans &gt; t) return ans;
        base *= base;
    }
    return ans;
}
 
int main() {
    
    freopen(&quot;cf1198a.in&quot;, &quot;r&quot;, stdin); 
    
    scanf(&quot;%d%d&quot;, &amp;n, &amp;I);
    for(int i=1; i&lt;=n; ++i) scanf(&quot;%d&quot;, a+i), b[i] = a[i];
    
    if(8*I &gt; n*((int)log2(n) + 1)) {
        printf(&quot;0\n&quot;);
        return 0;
    }
    
    sort(b+1, b+n+1);
    t = unique(b+1, b+n+1) - (b+1);
    
    int K = power(8*I/n);
    
    for(int i=1; i&lt;=n; ++i) {
        int p = lower_bound(b+1, b+t+1, a[i]) - b;
        ++cnt[p];
    }
    
    for(int i=1; i&lt;=t; ++i) s[i] = s[i-1] + cnt[i];
    
    int ans = 0x7fffffff;
    for(int l=1, r; l&lt;=t; ++l) {
        r = min(l + K - 1, t);
        ans = min(ans, s[t] - (s[r] - s[l-1]));
    }
    
    printf(&quot;%d\n&quot;, ans);
    
    return 0;
}
</code></pre>
<h2 id="cf180e-cubes">CF180E Cubes</h2>
<h3 id="题意简述">题意简述</h3>
<p>现有一数列 $a_1,a_2,…,a_n (1\leqslant a_i \leqslant m)$（更准确地翻译的话，现有一排小方块，第 $i$ 个方块的颜色为 $a_i$），求在最多删去 $k$ 个位置的数后，所能获得的最长连续子段的长度，要求该子段中所有数均相同．</p>
<h3 id="解释">解释</h3>
<ul>
<li>可以不删数．</li>
<li>$1 \leqslant n \leqslant 2 \times 10^5$，$1 \leqslant m \leqslant 10^5$，$0 \leqslant k &lt;n$．</li>
<li>样例#1：删去 $5th$ 和 $6th$．</li>
<li>样例#2：删去 $4th$ 和 $7th$．</li>
<li>样例#3：不变．</li>
</ul>
<h3 id="解答">解答</h3>
<p>枚举每种颜色，这样问题就可被简化为对于每种颜色，求出其修改后的最长合法子段，可用尺取法求解。</p>
<p>尺取法与单调队列有关，应用范围比较小，要求原问题在满足条件的情况下，长度越长，答案越好。利用双指针 $l,r$ 及队列思想，对于同一个 $l$ 让 $r$ 尽可能延伸至最远，得到一个答案区间，$r$ 已到达最远后将与 $l$ 有关的信息弹出，对于多个答案区间找出最优解。</p>
<p>更详细的解释请看<a href="%5Bhttps://www.baidu.com/s?ie=UTF-8&amp;wd=%E5%B0%BA%E5%8F%96%E6%B3%95%5D(https://www.baidu.com/s?ie=UTF-8&amp;wd=%E5%B0%BA%E5%8F%96%E6%B3%95)">这里</a></p>
<h3 id="代码-6">代码</h3>
<p>将原数列分块，对每种颜色建立链表，枚举时直接访问。</p>
<p>链表的每个节点存储该颜色块的左右端点。</p>
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;iostream&gt;
using namespace std;

const int N = 220000, M = 110000;

struct node {
    int l, r, next;
} a[N];

int tmp[M], n, m, k, h[M];

int main() {
    
    freopen(&quot;cf180e.in&quot;, &quot;r&quot;, stdin);
    
    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k);
    
    int f = 0, tot = 0, ans = 0;
    for(int i=1, c; i&lt;=n; ++i) {
        scanf(&quot;%d&quot;, &amp;c);
        if(f == c) a[tot].r = i;
        else {
            a[++tot] = (node) {i, i, c, 0};
            if(h[x]) a[tmp[c]].next = tmp[c] = tot;
            else h[x] = tmp[x] = tot;
            f = c;
        }
    }
    
    for(int i=1; i&lt;=m; ++i) {
        if(h[i] == 0) continue; // 无该颜色
        int L = h[i], R = h[i], f = 0, sum = a[h[i]].r - a[h[i]].l + 1;
        for(; L; L = a[L].next) {
            for(; a[R].next and f + a[a[R].next].l - a[R].r - 1 &lt;= k; R = a[R].next) 
                f += a[a[R].next].l - a[R].r - 1, 
                sum += a[a[R].next].r - a[a[R].next].l + 1;    
            ans = max(ans, sum); // 统计
            sum -= a[L].r - a[L].l + 1; // 弹出
            f -= a[a[L].next].l - a[L].r - 1;
        }
    }
    
    printf(&quot;%d\n&quot;, ans);
    
    return 0;
} 
</code></pre>
<h2 id="cf939e-maximize">CF939E Maximize!</h2>
<h3 id="题面-6">题面</h3>
<p>对于一个只包含正整数的 multiset $S$，你需要支持以下 $2$ 种操作：</p>
<ul>
<li>$1$
<ul>
<li>找出 $S$ 的一个子集 $s$，使 $max(s)-mean(s)$ 最大，并输出这个最大值。保留十位小数。</li>
</ul>
</li>
<li>$2$ $x$
<ul>
<li>加入一个新数 $x$ 到 $S$ 中，保证加入的数是递增的。</li>
</ul>
</li>
</ul>
<h3 id="解-6">解</h3>
<p>思维题。</p>
<p>$max$ 越大越好，$mean$ 越小越好。</p>
<p>结论一：子集 $s$ 中必包含 $\max S$。</p>
<p>结论二：$\forall x \in S, x\notin s,mean(s) &gt; x:mean(s) &lt; mean(s\cup{x})$​ 。</p>
<p>证明略。</p>
<h3 id="代码-7">代码</h3>
<p><del>略丑</del>。</p>
<p>为防止 WA，特判了较小的情况，维护的也略微麻烦一点。</p>
<pre><code class="language-cpp">#include &lt;stdio.h&gt;

const int N = 550000;
typedef double LF;

int Q, s[N];

int main() {
    
    freopen(&quot;cf939e.in&quot;, &quot;r&quot;, stdin);
    
    int tot = 0, f = 0;
    LF sum = 0, lastans = 0, lasttype = 0;
    
    scanf(&quot;%d&quot;, &amp;Q);
    
    while(Q--) {
    
        int type;
        scanf(&quot;%d&quot;, &amp;type);
        
        if(type == 1) {
            scanf(&quot;%d&quot;, &amp;s[++tot]);
            lasttype = type;
        }
        else {
            
            if(lasttype == 2) {
                printf(&quot;%.10lf\n&quot;, lastans);
                continue;
            }
            
            if(tot == 1) {
                printf(&quot;%.10lf\n&quot;, (LF)0);
                lastans = 0;
                lasttype = 2;
                continue;
            }
            
            if(tot == 2) {
                lastans = s[2] - (s[1] + s[2]) / 2.0;
                printf(&quot;%.10lf\n&quot;, lastans);
                lasttype = 2;
                sum = s[1], f = 1;
                continue;
            }
            
            for(int i=f+1; i&lt;tot; ++i) {
                if((LF)(sum + s[tot]) / i &gt; (LF)s[i]) f = i, sum += s[i];
                else break; 
            }
            
            lastans = s[tot] - (sum + s[tot]) / (f+1);
            printf(&quot;%.10lf\n&quot;, lastans);
            
            lasttype = type;
        }
    }
    
    return 0;
}
</code></pre>

        </div>
        
        <div class="my-4">
    
    <a href="https://www.atsnow.tk/tags/%E5%B0%BA%E5%8F%96%E6%B3%95/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka">#尺取法</a>
    
    <a href="https://www.atsnow.tk/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka">#双指针</a>
    
    <a href="https://www.atsnow.tk/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka">#单调队列</a>
    
    <a href="https://www.atsnow.tk/tags/%E7%AE%97%E6%B3%95/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka">#算法</a>
    
</div>
        
        
        
        
        
        
        
<div class="flex flex-col md:flex-row md:justify-between -mx-2 mt-4 px-2 pt-4 border-t">
    <div>
        
        <span class="block font-bold">上一页</span>
        <a href="https://www.atsnow.tk/hexo-vercel/" class="block">Hexo：将你的博客部署到 Vercel</a>
        
    </div>
    <div class="md:text-right mt-4 md:mt-0">
        
        <span class="block font-bold">下一页</span>
        <a href="https://www.atsnow.tk/about-codestyle/" class="block">About CODESTYLE</a>
        
    </div>
</div>

        
    </div>
    
    <div class="col-span-2">
        
        
        <div class="sticky top-16 z-10 hidden lg:block px-6 py-4  bg-primary-bg ">
    <span class="text-lg font-semibold">本页内容</span>
</div>
<div class="sticky-toc hidden lg:block px-6 pb-6 ">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#hdu5178-pairs">HDU5178 Pairs</a>
      <ul>
        <li><a href="#题面">题面</a></li>
        <li><a href="#解">解</a></li>
        <li><a href="#代码">代码</a></li>
      </ul>
    </li>
    <li><a href="#hdu6119-小小粉丝度度熊">HDU6119 小小粉丝度度熊</a>
      <ul>
        <li><a href="#题面-1">题面</a></li>
        <li><a href="#解-1">解</a></li>
        <li><a href="#代码-1">代码</a></li>
      </ul>
    </li>
    <li><a href="#hdu1937-finding-seats">HDU1937 Finding Seats</a>
      <ul>
        <li><a href="#题面-2">题面</a></li>
        <li><a href="#解-2">解</a></li>
        <li><a href="#代码-2">代码</a></li>
      </ul>
    </li>
    <li><a href="#hdu5358-first-one">HDU5358 First One</a>
      <ul>
        <li><a href="#题面-3">题面</a></li>
        <li><a href="#解-3">解</a></li>
        <li><a href="#代码-3">代码</a></li>
      </ul>
    </li>
    <li><a href="#hdu6103-kirinriki">HDU6103 Kirinriki</a>
      <ul>
        <li><a href="#题面-4">题面</a></li>
        <li><a href="#解-4">解</a></li>
        <li><a href="#代码-4">代码</a></li>
      </ul>
    </li>
    <li><a href="#poj2739-sum-of-consecutive-prime-numbers">POJ2739 Sum of Consecutive Prime Numbers</a></li>
    <li><a href="#cf1198a-mp3">CF1198A MP3</a>
      <ul>
        <li><a href="#题面-5">题面</a></li>
        <li><a href="#解-5">解</a></li>
        <li><a href="#代码-5">代码</a></li>
      </ul>
    </li>
    <li><a href="#cf180e-cubes">CF180E Cubes</a>
      <ul>
        <li><a href="#题意简述">题意简述</a></li>
        <li><a href="#解释">解释</a></li>
        <li><a href="#解答">解答</a></li>
        <li><a href="#代码-6">代码</a></li>
      </ul>
    </li>
    <li><a href="#cf939e-maximize">CF939E Maximize!</a>
      <ul>
        <li><a href="#题面-6">题面</a></li>
        <li><a href="#解-6">解</a></li>
        <li><a href="#代码-7">代码</a></li>
      </ul>
    </li>
  </ul>
</nav>
</div>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        enableStickyToc();
    });
</script>
        
    </div>
    

    
    
    <div
        class="col-span-2  lg:col-span-6 bg-secondary-bg rounded p-6">
        <h2 class="text-lg font-semibold mb-4">相关</h2>
        <div class="content">
            
            <a href="https://www.atsnow.tk/monotonous-queue/">单调队列</a>
            <br />
            
            <a href="https://www.atsnow.tk/about-codestyle/">About CODESTYLE</a>
            <br />
            
            <a href="https://www.atsnow.tk/cf387d/">CF387D</a>
            <br />
            
            <a href="https://www.atsnow.tk/about-splay/">浅谈 Splay（一）</a>
            <br />
            
            <a href="https://www.atsnow.tk/minimum-cut/">网络流：最小割</a>
            <br />
            
            <a href="https://www.atsnow.tk/stl-set/">C&#43;&#43; STL：SET &amp; MULTISET</a>
            <br />
            
        </div>
    </div>
    
</div>
<script>
    document.addEventListener('DOMContentLoaded', ()=>{
        hljs.initHighlightingOnLoad();
    })
</script>

      </div>
    </div>
    
  </main>
  <footer class="pl-scrollbar">
    <div class="w-full max-w-screen-xl mx-auto"><div class="text-center p-6 pin-b">
    <p class="text-sm text-tertiary-text">&copy; 2021 <a href="https://www.wangchucheng.com/">C. Wang</a> and <a href="https://www.ruiqima.com/">R. Ma</a> &middot;  Powered by the <a href="https://github.com/wangchucheng/hugo-eureka" class="hover:text-eureka">Eureka</a> theme for <a href="https://gohugo.io" class="hover:text-eureka">Hugo</a></p>
</div></div>
  </footer>
</body>

</html>